use lalrpop_util::ParseError;
use std::str::FromStr;
use crate::ast::*;

grammar;

extern {
	type Error = String;
}

// ### Values ###

pub Identifier: &'input str = r"[a-zA-Z_#][a-zA-Z0-9_#]*";
pub Integer: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
pub Decimal: f64 = <s:r"[0-9]*\.[0-9]+"> => f64::from_str(s).unwrap();
pub Character: char = <s:r#"'(\\.|[^\\"])'"#> =>? Literal::unescape_char(s);
pub String: &'input str = r#""(\\.|[^\\"])*""#;
pub Boolean: bool = {
    "true" => true,
    "false" => false,
};

pub Literal: Literal<'input> = {
    "?" => Literal::Uninit,
	Identifier => Literal::Id(<>),
	Integer => Literal::Integer(<>),
	Decimal => Literal::Decimal(<>),
	Character => Literal::Char(<>),
	String => Literal::String(<>),
	Boolean => Literal::Boolean(<>),
}

// FIXME "2 * (6 / 3)" breaks parsing
pub Expression: Expression<'input> = {
    <l:Expression> "+" <r:Factor> => l + r,
    <l:Expression> "-" <r:Factor> => l - r,
    Factor,
};

Factor: Expression<'input> = {
    <l:Factor> "*" <r:Term> => l * r,
    <l:Factor> "/" <r:Term> => l / r,
    Term,
};

Term: Expression<'input> = {
    Literal => Expression::Literal(<>),
    "(" <Expression> ")",
};

// ### Objects ###

pub SymbolDeclaration: SymbolDeclaration<'input> = {
    <public: "pub"?> "def" <name: Identifier> ":" <symbol: Symbol>
        => SymbolDeclaration { public: public.is_some(), name, symbol }
}

pub Symbol: Symbol<'input> = {
    "struct" "{" <members: CommaSeparatedList<StructMember>> "}"
        => Symbol::Struct(Struct { <> }),

    "(" <params: CommaSeparatedList<FunctionParameter>> ")" "->" <return_ty: Type> <block: Block>
        => Symbol::Function(Function { params, return_ty, block: Some(block) }),
}

pub StructMember: StructMember<'input> = {
    <name: Identifier> ":" <ty: Type>
        => StructMember { <> }
}

pub FunctionParameter: FunctionParameter<'input> = {
    <name: Identifier> ":" <ty: Type>
        => FunctionParameter { <> }
}

pub Type: Type<'input> = {
    Identifier => Type::Id(<>)
}

// ### Statements ###

pub Block: Block<'input> = {
    "{" <statements: Statement*> "}"
        => Block { <> }
}

pub Statement: Statement<'input> = {
    "let" <mutable: "mut"?> <name: Identifier> <ty: TypeSpecifier?> "=" <value: Expression> ";"
        =>? Ok(Statement::VarDecl(VarDecl::new(name, mutable.is_some(), ty, value)?)),

    "return" <expr: Expression?> ";" =>
         Statement::Return(<>),

    "yield" <expr: Expression?> ";" =>
          Statement::Yield(<>),
}

pub CompilationUnit: CompilationUnit<'input> = {
    "namespace" <namespace:Namespace> ";"
    <imports:NamespaceImport*>
    <declarations: SymbolDeclaration*>
        => CompilationUnit { <> }
}

pub NamespaceImport: NamespaceImport<'input> = {
    "import" <id:Namespace> ";"
        => NamespaceImport(id)
}

// ### Utilities ###

Namespace: &'input str = {
	<v:(Identifier "::")*> <e:Identifier> => match v.is_empty() {
	    true => e,
	    false => unsafe {
	        let start = v[0].0.as_ptr();
	        let end = e.as_ptr().add(e.len());
	        let len = end as usize - start as usize;
	        let slice = std::slice::from_raw_parts(start, len);
	        std::str::from_utf8_unchecked(slice)
	    }
	}
};

CommaSeparatedList<T>: Vec<T> = {
	<mut v:(<T> ",")*> <e:T?> => match e {
		None => v,
		Some(e) => {
			v.push(e);
			v
		}
	}
};

TypeSpecifier: Type<'input> = {
    ":" <ty: Type> => ty
}
